                      *Creation d'une table dans une base de donne

pour creer la table dans la base de donne, on a utilise la syntaxe suivante
create 'nom de la table'(champ1 'type',champ2'type'.....);

                     *Insertion des champ et leur valeur dans une base de donne
CREATE TABLE recipes
(
title varchar(50),
slug varchar (50),
content TEXT,
duration SMALLINT,
online BOOLEAN,
created_at DATETIME
);
INSERT INTO recipes(
title,
slug,
content,
duration,
online,
created_at
)
VALUES(
'salade de fruit',
'salade_de_fruit',
'contenue_de_text',
30,
true,
1671801925
);
                           *Notion d'id de cles primaire,etrangere et jointure

Pour pouvoir creer des table avec des id et et les donnes la valeur de cles primaire et cles etrangere  et inserer des information dans les differents on n'a utiliser la syntaxe suivante:
PRAGMA foreign_keys = ON;
CREATE TABLE IF NOT EXISTS categorie(
id integer PRIMARY KEY AUTOINCREMENT,
title varchar(50) NOT NULL,
description text
);
INSERT INTO categorie(title)
VALUES
('plat'),('dessert');
CREATE TABLE recipes(
id integer PRIMARY KEY AUTOINCREMENT NOT NULL,
title varchar(50)NOT NULL,
slug varchar(50)NOT NULL,
content text,
categorie_id integer,
duration smallint
FOREIGN KEY(categorie_id)REFERENCES categorie (id)
);
INSERT INTO recipes(title,slug,categorie_id)
VALUES
('creme anglise','creme-anglaise',2,10),
('soupe','soupe',1,20),
('salade de fruit','salade-de-fruit',2,30);
                      
 Pour pouvoir afficher le resultat on a du faire une jointure deux deux table en utilisant la syntaxe suivante:

-SELECT * FROM recipes  JOIN categorie  ON recipes.categorie_id= categorie.id; 
ce qui nous a donne le resultat visible dans notre dossier sql de notre depot

                             *Fonction d'agregation

-SELECT COUNT(nom du champ)FROM nom de la table; :cette requette nous permet de  compter le nombre de valeurs que comporte 
un champ     Exemple: SELECT COUNT(id)FROM recipes qui nous donnera 3

-SELECT GROUP CONTACT(nom du champ)FROM nom de la table; : cette requette nous permet de faire la concatenation des different
valeur d'une table  Exemple: SELECT GROUP CONTACT(title)FROM recipes  qui nous donnera la liste de tout les titre de la table 
 
-SELECT sum(nom du champ)FROM nom de la table : cette requette nous permet de faire pour un champ la somme valeur numerique 
 
-SELECT COUNT(champ1),champ2 FROM nom de la table GROUP BY champ2; :cette requette nous permetra
 de compter le nombre de 'champ1' et les separer par 'champ2' correspondant au 'champ1' 
Exemple :SELCT COUNT(id),duration FROM recipes GROUP BY duration
 
-SElECT DISTINCT (nom de champ)FROM nom de la table; : pour une champ contenant plusieur meme valeurs cette requette permet
 de ne pa dupliquer les differentes valeurs identique lors de l'afficharge 



                                      * Order,limite,max et min

-SELECT* FROM nom de la table ORDER BY nom du champ : cette requett nous permetra de d'afficher les valeur des champ selon
un odre precis. elle a deux attribu DESC qui affichera dans l'ordre decroissant et ASC dans l'odre croissant 
 
-SELECTSELECT* FROM nom de la atable LIMIT nombre limite: cette requette nous permetra de le limter le nombre de valeur
d'un champ que l'on voudras afficher du haut vers le bas elle peut avoir comme attribue OFFSET 'numero de la ligne' qui 
permetra d'indiquer a partir de quelle ligne la commande LIMIT s'executera

-SELECT MAX(nom de la colonne) FROM nom de la table;:cette requetteest utilise pour retourner la valeur maximum de la colonne 
 qui ne s'applique que a des valeur numerique ou alphanumerique
 
--SELECT MIN(nom de la colonne) FROM nom de la table;:cette requetteest utilise pour retourner la valeur minimale de la colonne 
 qui ne s'applique que a des valeurs numerique ou alphanumerique
                      
                                 *Notion de transaction et sous requettes 

-BEGING TRANSACTION : cette requette permet de prevoir a l'avance une eventuelle erreur que l'on pourai connaitre dans l'e-
xecution de nos requettes Exemple: L'on execute d'abord la requette BEGING TRANSACTION  l'on peut supprimer un  champ avec
 la requette suivante DELETE FROM nom de la table
WHERE id=1; apres l'avoir suprimmer l'on se rend compte que c'est pas vraiment l'action que l'on voulais effectuer l'on peut
 utiliser la conmmande ROLLBACK TRANSACTION; elle nous restitura nos  valeur que l'on viens de supprimer. ce pendant si 
apres avoir execute nos requettes et que l'on est satisfait du resultat l'on pourra enregistre cela dans la base de donne
avec la commande COMMIT TRANSACTION;


-les sous rerquette permettent d'effectuer une requette et de recuperer le resultat pour l'effetuer dans une autre requette
 
Exemple: SELECT*,(SELECT COUNT(*) FROM table1) FROM table2;
cette requette va afficher tout les element de la table2 avec une colonne suplementaire qui me donnera le nombre d'id de la
table1 

                                                 
                                                *Notion de view et triggers


-CREATE VIEW permet de creer une table virtuelle qui vas etre le resultat une requette particiliere. c'est a dire que lors
de notre gestion de donné, nous pourrons etre appelé a saisir une requette complex pour afficher un resultat;nous pourons 
donc resumer cette requette en utilisant un CRAETE VIEW (non de la vue)AS (requette )
Exemple: CREATE VIEW hurtel AS SELECT * FROM recipes  JOIN categorie  ON recipes.categorie_id= categorie.id;


-CREATE TRIGGERS encore appelé declancheur permet d'executer un ensemble d'instruction juste apres un evenement.ce qui 
permet d'automatiser les action au sein d'un systeme de gestion de base de donne. 
Exemple:
CREATE TRIGGER  nom trigger 
{BEFORE | AFTER} {INSERT | UPDATE| DELETE }
ON  nom de la table FOR EACH ROW
 corp du trigger; 

